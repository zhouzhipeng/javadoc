<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_112) on Sat Sep 01 15:33:59 CST 2018 -->
<title>InjectMocks</title>
<meta name="date" content="2018-09-01">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="InjectMocks";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.mockito</div>
<h2 title="注释类型 InjectMocks" class="title">注释类型 InjectMocks</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html?is-external=true" title="java.lang.annotation中的类或接口">@Documented</a>
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true" title="java.lang.annotation中的类或接口">@Target</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true#value--" title="java.lang.annotation中的类或接口">value</a>=<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#FIELD" title="java.lang.annotation中的类或接口">FIELD</a>)
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true" title="java.lang.annotation中的类或接口">@Retention</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true#value--" title="java.lang.annotation中的类或接口">value</a>=<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html?is-external=true#RUNTIME" title="java.lang.annotation中的类或接口">RUNTIME</a>)
public @interface <span class="memberNameLabel">InjectMocks</span></pre>
<div class="block">Mark a field on which injection should be performed.

 <ul>
 <li>Allows shorthand mock and spy injection.</li>
 <li>Minimizes repetitive mock and spy injection.</li>
 </ul>
 <p>
 Mockito will try to inject mocks only either by constructor injection,
 setter injection, or property injection in order and as described below.
 If any of the following strategy fail, then Mockito <strong>won't report failure</strong>;
 i.e. you will have to provide dependencies yourself.
 <ol>
     <li><strong>Constructor injection</strong>; the biggest constructor is chosen,
     then arguments are resolved with mocks declared in the test only. If the object is successfully created
     with the constructor, then <strong>Mockito won't try the other strategies</strong>. Mockito has decided to no
     corrupt an object if it has a parametered constructor.
     <p><u>Note:</u> If arguments can not be found, then null is passed.
     If non-mockable types are wanted, then constructor injection won't happen.
     In these cases, you will have to satisfy dependencies yourself.</p></li>

     <li><strong>Property setter injection</strong>; mocks will first be resolved by type (if a single type match
     injection will happen regardless of the name),
     then, if there is several property of the same type, by the match of the property name and the mock name.
     <p><u>Note 1:</u> If you have properties with the same type (or same erasure), it's better to name all &#064;Mock
     annotated fields with the matching properties, otherwise Mockito might get confused and injection won't happen.</p>
     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,
     then it will be initialized with this constructor.</p></li>

     <li><strong>Field injection</strong>; mocks will first be resolved by type (if a single type match
     injection will happen regardless of the name),
     then, if there is several property of the same type, by the match of the field name and the mock name.
     <p><u>Note 1:</u> If you have fields with the same type (or same erasure), it's better to name all &#064;Mock
     annotated fields with the matching fields, otherwise Mockito might get confused and injection won't happen.</p>
     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,
     then it will be initialized with this constructor.</p></li>
 </ol>
 </p>

 <p>
 Example:
 <pre class="code"><code class="java">
   public class ArticleManagerTest extends SampleBaseTestCase {

       &#064;Mock private ArticleCalculator calculator;
       &#064;Mock(name = "database") private ArticleDatabase dbMock; // note the mock name attribute
       &#064;Spy private UserProvider userProvider = new ConsumerUserProvider();

       &#064;InjectMocks private ArticleManager manager;

       &#064;Test public void shouldDoSomething() {
           manager.initiateArticle();
           verify(database).addListener(any(ArticleListener.class));
       }
   }

   public class SampleBaseTestCase {

       &#064;Before public void initMocks() {
           MockitoAnnotations.initMocks(this);
       }
   }
 </code></pre>
 </p>

 <p>
 In the above example the field <code>ArticleManager</code> annotated with <code>&#064;InjectMocks</code> can have
 a parameterized constructor only or a no-arg constructor only, or both.
 All these constructors can be package protected, protected or private, however
 <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>
 <u>Beware of private nest static classes too.</u>

 <p>The same stands for setters or fields, they can be declared with private
 visibility, Mockito will see them through reflection.
 However fields that are static or final will be ignored.</p>

 <p>So on the field that needs injection, for example constructor injection will happen here :</p>
 <pre class="code"><code class="java">
   public class ArticleManager {
       ArticleManager(ArticleCalculator calculator, ArticleDatabase database) {
           // parameterized constructor
       }
   }
 </code></pre>

 <p>Property setter injection will happen here :</p>
 <pre class="code"><code class="java">
   public class ArticleManager {
       // no-arg constructor
       ArticleManager() {  }

       // setter
       void setDatabase(ArticleDatabase database) { }

       // setter
       void setCalculator(ArticleCalculator calculator) { }
   }
 </code></pre>

 <p>Field injection will be used here :</p>
 <pre class="code"><code class="java">
   public class ArticleManager {
       private ArticleDatabase database;
       private ArticleCalculator calculator;
   }
 </code></pre>
 </p>

 <p>And finally, no injection will happen on the type in this case:</p>
 <pre class="code"><code class="java">
   public class ArticleManager {
       private ArticleDatabase database;
       private ArticleCalculator calculator;

       ArticleManager(ArticleObserver observer, boolean flag) {
           // observer is not declared in the test above.
           // flag is not mockable anyway
       }
   }
 </code></pre>
 </p>


 <p>
 Again, note that &#064;InjectMocks will only inject mocks/spies created using the &#64;Spy or &#64;Mock annotation.
 </p>

 <p>
 <strong><code>MockitoAnnotations.initMocks(this)</code></strong> method has to be called to initialize annotated objects.
 In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
 For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.
 <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in
 <code>MockitoJUnitRunner</code>.
 </p>

 <p>
 Mockito is not an dependency injection framework, don't expect this shorthand utility to inject a complex graph of objects
 be it mocks/spies or real objects.
 </p></div>
<dl>
<dt><span class="simpleTagLabel">从以下版本开始:</span></dt>
<dd>1.8.3</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>Mock</code>, 
<code>Spy</code>, 
<code>MockitoAnnotations.initMocks(Object)</code>, 
<code>MockitoJUnitRunner</code></dd>
</dl>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</body>
</html>
