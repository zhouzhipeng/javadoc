<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_112) on Sat Sep 01 15:37:59 CST 2018 -->
<title>WebApplicationInitializer</title>
<meta name="date" content="2018-09-01">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="WebApplicationInitializer";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6};
var tabs = {65535:["t0","所有方法"],2:["t2","实例方法"],4:["t3","抽象方法"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.springframework.web</div>
<h2 title="接口 WebApplicationInitializer" class="title">接口 WebApplicationInitializer</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>所有已知实现类:</dt>
<dd><a href="../../../org/springframework/web/servlet/support/AbstractAnnotationConfigDispatcherServletInitializer.html" title="org.springframework.web.servlet.support中的类">AbstractAnnotationConfigDispatcherServletInitializer</a>, <a href="../../../org/springframework/web/context/AbstractContextLoaderInitializer.html" title="org.springframework.web.context中的类">AbstractContextLoaderInitializer</a>, <a href="../../../org/springframework/web/servlet/support/AbstractDispatcherServletInitializer.html" title="org.springframework.web.servlet.support中的类">AbstractDispatcherServletInitializer</a>, <a href="../../../org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html" title="org.springframework.web.server.adapter中的类">AbstractReactiveWebInitializer</a></dd>
</dl>
<hr>
<br>
<pre>public interface <span class="typeNameLabel">WebApplicationInitializer</span></pre>
<div class="block">Interface to be implemented in Servlet 3.0+ environments in order to configure the
 <code>ServletContext</code> programmatically -- as opposed to (or possibly in conjunction
 with) the traditional <code>web.xml</code>-based approach.

 <p>Implementations of this SPI will be detected automatically by <a href="../../../org/springframework/web/SpringServletContainerInitializer.html" title="org.springframework.web中的类"><code>SpringServletContainerInitializer</code></a>, which itself is bootstrapped automatically
 by any Servlet 3.0 container. See <a href="../../../org/springframework/web/SpringServletContainerInitializer.html" title="org.springframework.web中的类">its
 Javadoc</a> for details on this bootstrapping mechanism.

 <h2>Example</h2>
 <h3>The traditional, XML-based approach</h3>
 Most Spring users building a web application will need to register Spring's <code>DispatcherServlet</code>. For reference, in WEB-INF/web.xml, this would typically be done as
 follows:
 <pre class="code">
 <code>&lt;servlet&gt;
   &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
   &lt;servlet-class&gt;
     org.springframework.web.servlet.DispatcherServlet
   &lt;/servlet-class&gt;
   &lt;init-param&gt;
     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
     &lt;param-value&gt;/WEB-INF/spring/dispatcher-config.xml&lt;/param-value&gt;
   &lt;/init-param&gt;
   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
 &lt;/servlet&gt;

 &lt;servlet-mapping&gt;
   &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
   &lt;url-pattern&gt;/&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;</code></pre>

 <h3>The code-based approach with <code>WebApplicationInitializer</code></h3>
 Here is the equivalent <code>DispatcherServlet</code> registration logic,
 <code>WebApplicationInitializer</code>-style:
 <pre class="code">
 public class MyWebAppInitializer implements WebApplicationInitializer {

    &#064;Override
    public void onStartup(ServletContext container) {
      XmlWebApplicationContext appContext = new XmlWebApplicationContext();
      appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

      ServletRegistration.Dynamic dispatcher =
        container.addServlet("dispatcher", new DispatcherServlet(appContext));
      dispatcher.setLoadOnStartup(1);
      dispatcher.addMapping("/");
    }

 }</pre>

 As an alternative to the above, you can also extend from <a href="../../../org/springframework/web/servlet/support/AbstractDispatcherServletInitializer.html" title="org.springframework.web.servlet.support中的类"><code>AbstractDispatcherServletInitializer</code></a>.

 As you can see, thanks to Servlet 3.0's new <code>ServletContext.addServlet(java.lang.String, java.lang.String)</code> method
 we're actually registering an <em>instance</em> of the <code>DispatcherServlet</code>, and
 this means that the <code>DispatcherServlet</code> can now be treated like any other object
 -- receiving constructor injection of its application context in this case.

 <p>This style is both simpler and more concise. There is no concern for dealing with
 init-params, etc, just normal JavaBean-style properties and constructor arguments. You
 are free to create and work with your Spring application contexts as necessary before
 injecting them into the <code>DispatcherServlet</code>.

 <p>Most major Spring Web components have been updated to support this style of
 registration.  You'll find that <code>DispatcherServlet</code>, <code>FrameworkServlet</code>,
 <code>ContextLoaderListener</code> and <code>DelegatingFilterProxy</code> all now support
 constructor arguments. Even if a component (e.g. non-Spring, other third party) has not
 been specifically updated for use within <code>WebApplicationInitializers</code>, they still
 may be used in any case. The Servlet 3.0 <code>ServletContext</code> API allows for setting
 init-params, context-params, etc programmatically.

 <h2>A 100% code-based approach to configuration</h2>
 In the example above, <code>WEB-INF/web.xml</code> was successfully replaced with code in
 the form of a <code>WebApplicationInitializer</code>, but the actual
 <code>dispatcher-config.xml</code> Spring configuration remained XML-based.
 <code>WebApplicationInitializer</code> is a perfect fit for use with Spring's code-based
 <code>@Configuration</code> classes. See @<code>Configuration</code> Javadoc for
 complete details, but the following example demonstrates refactoring to use Spring's
 <a href="../../../org/springframework/web/context/support/AnnotationConfigWebApplicationContext.html" title="org.springframework.web.context.support中的类"><code>AnnotationConfigWebApplicationContext</code></a> in lieu of <code>XmlWebApplicationContext</code>, and
 user-defined <code>@Configuration</code> classes <code>AppConfig</code> and
 <code>DispatcherConfig</code> instead of Spring XML files. This example also goes a bit
 beyond those above to demonstrate typical configuration of the 'root' application
 context and registration of the <code>ContextLoaderListener</code>:
 <pre class="code">
 public class MyWebAppInitializer implements WebApplicationInitializer {

    &#064;Override
    public void onStartup(ServletContext container) {
      // Create the 'root' Spring application context
      AnnotationConfigWebApplicationContext rootContext =
        new AnnotationConfigWebApplicationContext();
      rootContext.register(AppConfig.class);

      // Manage the lifecycle of the root application context
      container.addListener(new ContextLoaderListener(rootContext));

      // Create the dispatcher servlet's Spring application context
      AnnotationConfigWebApplicationContext dispatcherContext =
        new AnnotationConfigWebApplicationContext();
      dispatcherContext.register(DispatcherConfig.class);

      // Register and map the dispatcher servlet
      ServletRegistration.Dynamic dispatcher =
        container.addServlet("dispatcher", new DispatcherServlet(dispatcherContext));
      dispatcher.setLoadOnStartup(1);
      dispatcher.addMapping("/");
    }

 }</pre>

 As an alternative to the above, you can also extend from <a href="../../../org/springframework/web/servlet/support/AbstractAnnotationConfigDispatcherServletInitializer.html" title="org.springframework.web.servlet.support中的类"><code>AbstractAnnotationConfigDispatcherServletInitializer</code></a>.

 Remember that <code>WebApplicationInitializer</code> implementations are <em>detected
 automatically</em> -- so you are free to package them within your application as you
 see fit.

 <h2>Ordering <code>WebApplicationInitializer</code> execution</h2>
 <code>WebApplicationInitializer</code> implementations may optionally be annotated at the
 class level with Spring's @<code>Order</code>
 annotation or may implement Spring's <code>Ordered</code>
 interface. If so, the initializers will be ordered prior to invocation. This provides
 a mechanism for users to ensure the order in which servlet container initialization
 occurs. Use of this feature is expected to be rare, as typical applications will likely
 centralize all container initialization within a single <code>WebApplicationInitializer</code>.

 <h2>Caveats</h2>

 <h3>web.xml versioning</h3>
 <p><code>WEB-INF/web.xml</code> and <code>WebApplicationInitializer</code> use are not mutually
 exclusive; for example, web.xml can register one servlet, and a <code>WebApplicationInitializer</code> can register another. An initializer can even
 <em>modify</em> registrations performed in <code>web.xml</code> through methods such as
 <code>ServletContext.getServletRegistration(String)</code>. <strong>However, if
 <code>WEB-INF/web.xml</code> is present in the application, its <code>version</code> attribute
 must be set to "3.0" or greater, otherwise <code>ServletContainerInitializer</code>
 bootstrapping will be ignored by the servlet container.</strong>

 <h3>Mapping to '/' under Tomcat</h3>
 <p>Apache Tomcat maps its internal <code>DefaultServlet</code> to "/", and on Tomcat versions
 &lt;= 7.0.14, this servlet mapping <em>cannot be overridden programmatically</em>.
 7.0.15 fixes this issue. Overriding the "/" servlet mapping has also been tested
 successfully under GlassFish 3.1.<p></div>
<dl>
<dt><span class="simpleTagLabel">从以下版本开始:</span></dt>
<dd>3.1</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../org/springframework/web/SpringServletContainerInitializer.html" title="org.springframework.web中的类"><code>SpringServletContainerInitializer</code></a>, 
<a href="../../../org/springframework/web/context/AbstractContextLoaderInitializer.html" title="org.springframework.web.context中的类"><code>AbstractContextLoaderInitializer</code></a>, 
<a href="../../../org/springframework/web/servlet/support/AbstractDispatcherServletInitializer.html" title="org.springframework.web.servlet.support中的类"><code>AbstractDispatcherServletInitializer</code></a>, 
<a href="../../../org/springframework/web/servlet/support/AbstractAnnotationConfigDispatcherServletInitializer.html" title="org.springframework.web.servlet.support中的类"><code>AbstractAnnotationConfigDispatcherServletInitializer</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>方法概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="方法概要表, 列表方法和解释">
<caption><span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/springframework/web/WebApplicationInitializer.html#onStartup-javax.servlet.ServletContext-">onStartup</a></span>(javax.servlet.ServletContext&nbsp;servletContext)</code>
<div class="block">Configure the given <code>ServletContext</code> with any servlets, filters, listeners
 context-params and attributes necessary for initializing this web application.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>方法详细资料</h3>
<a name="onStartup-javax.servlet.ServletContext-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>onStartup</h4>
<pre>void&nbsp;onStartup(javax.servlet.ServletContext&nbsp;servletContext)
        throws javax.servlet.ServletException</pre>
<div class="block">Configure the given <code>ServletContext</code> with any servlets, filters, listeners
 context-params and attributes necessary for initializing this web application. See
 examples <a href="../../../org/springframework/web/WebApplicationInitializer.html" title="org.springframework.web中的接口">above</a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>servletContext</code> - the <code>ServletContext</code> to initialize</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>javax.servlet.ServletException</code> - if any call against the given <code>ServletContext</code>
 throws a <code>ServletException</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</body>
</html>
