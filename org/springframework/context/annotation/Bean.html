<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_112) on Sat Sep 01 15:36:20 CST 2018 -->
<title>Bean</title>
<meta name="date" content="2018-09-01">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Bean";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.springframework.context.annotation</div>
<h2 title="注释类型 Bean" class="title">注释类型 Bean</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true" title="java.lang.annotation中的类或接口">@Target</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true#value--" title="java.lang.annotation中的类或接口">value</a>={<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#METHOD" title="java.lang.annotation中的类或接口">METHOD</a>,<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#ANNOTATION_TYPE" title="java.lang.annotation中的类或接口">ANNOTATION_TYPE</a>})
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true" title="java.lang.annotation中的类或接口">@Retention</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true#value--" title="java.lang.annotation中的类或接口">value</a>=<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html?is-external=true#RUNTIME" title="java.lang.annotation中的类或接口">RUNTIME</a>)
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html?is-external=true" title="java.lang.annotation中的类或接口">@Documented</a>
public @interface <span class="memberNameLabel">Bean</span></pre>
<div class="block">Indicates that a method produces a bean to be managed by the Spring container.

 <h3>Overview</h3>

 <p>The names and semantics of the attributes to this annotation are intentionally
 similar to those of the <code>&lt;bean/&gt;</code> element in the Spring XML schema. For
 example:

 <pre class="code">
     &#064;Bean
     public MyBean myBean() {
         // instantiate and configure MyBean obj
         return obj;
     }
 </pre>

 <h3>Bean Names</h3>

 <p>While a <a href="../../../../org/springframework/context/annotation/Bean.html#name--"><code>name()</code></a> attribute is available, the default strategy for
 determining the name of a bean is to use the name of the <code>@Bean</code> method.
 This is convenient and intuitive, but if explicit naming is desired, the
 <code>name</code> attribute (or its alias <code>value</code>) may be used. Also note
 that <code>name</code> accepts an array of Strings, allowing for multiple names
 (i.e. a primary bean name plus one or more aliases) for a single bean.

 <pre class="code">
     &#064;Bean({"b1", "b2"}) // bean available as 'b1' and 'b2', but not 'myBean'
     public MyBean myBean() {
         // instantiate and configure MyBean obj
         return obj;
     }
 </pre>

 <h3>Profile, Scope, Lazy, DependsOn, Primary, Order</h3>

 <p>Note that the <code>@Bean</code> annotation does not provide attributes for profile,
 scope, lazy, depends-on or primary. Rather, it should be used in conjunction with
 <a href="../../../../org/springframework/context/annotation/Scope.html" title="org.springframework.context.annotation中的注释"><code>@Scope</code></a>, <a href="../../../../org/springframework/context/annotation/Lazy.html" title="org.springframework.context.annotation中的注释"><code>@Lazy</code></a>, <a href="../../../../org/springframework/context/annotation/DependsOn.html" title="org.springframework.context.annotation中的注释"><code>@DependsOn</code></a> and
 <a href="../../../../org/springframework/context/annotation/Primary.html" title="org.springframework.context.annotation中的注释"><code>@Primary</code></a> annotations to declare those semantics. For example:

 <pre class="code">
     &#064;Bean
     &#064;Profile("production")
     &#064;Scope("prototype")
     public MyBean myBean() {
         // instantiate and configure MyBean obj
         return obj;
     }
 </pre>

 The semantics of the above-mentioned annotations match their use at the component
 class level: <code>@Profile</code> allows for selective inclusion of certain beans.
 <code>@Scope</code> changes the bean's scope from singleton to the specified scope.
 <code>@Lazy</code> only has an actual effect in case of the default singleton scope.
 <code>@DependsOn</code> enforces the creation of specific other beans before this
 bean will be created, in addition to any dependencies that the bean expressed
 through direct references, which is typically helpful for singleton startup.
 <code>@Primary</code> is a mechanism to resolve ambiguity at the injection point level
 if a single target component needs to be injected but several beans match by type.

 <p>Additionally, <code>@Bean</code> methods may also declare qualifier annotations
 and <a href="../../../../org/springframework/core/annotation/Order.html" title="org.springframework.core.annotation中的注释"><code>@Order</code></a> values, to be
 taken into account during injection point resolution just like corresponding
 annotations on the corresponding component classes but potentially being very
 individual per bean definition (in case of multiple definitions with the same
 bean class). Qualifiers narrow the set of candidates after the initial type match;
 order values determine the order of resolved elements in case of collection
 injection points (with several target beans matching by type and qualifier).

 <p><b>NOTE:</b> <code>@Order</code> values may influence priorities at injection points,
 but please be aware that they do not influence singleton startup order which is an
 orthogonal concern determined by dependency relationships and <code>@DependsOn</code>
 declarations as mentioned above. Also, <a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Priority.html?is-external=true" title="javax.annotation中的类或接口"><code>Priority</code></a> is not
 available at this level since it cannot be declared on methods; its semantics can
 be modeled through <code>@Order</code> values in combination with <code>@Primary</code> on
 a single bean per type.

 <h3><code>@Bean</code> Methods in <code>@Configuration</code> Classes</h3>

 <p>Typically, <code>@Bean</code> methods are declared within <code>@Configuration</code>
 classes. In this case, bean methods may reference other <code>@Bean</code> methods in the
 same class by calling them <i>directly</i>. This ensures that references between beans
 are strongly typed and navigable. Such so-called <em>'inter-bean references'</em> are
 guaranteed to respect scoping and AOP semantics, just like <code>getBean()</code> lookups
 would. These are the semantics known from the original 'Spring JavaConfig' project
 which require CGLIB subclassing of each such configuration class at runtime. As a
 consequence, <code>@Configuration</code> classes and their factory methods must not be
 marked as final or private in this mode. For example:

 <pre class="code">
 &#064;Configuration
 public class AppConfig {

     &#064;Bean
     public FooService fooService() {
         return new FooService(fooRepository());
     }

     &#064;Bean
     public FooRepository fooRepository() {
         return new JdbcFooRepository(dataSource());
     }

     // ...
 }</pre>

 <h3><code>@Bean</code> <em>Lite</em> Mode</h3>

 <p><code>@Bean</code> methods may also be declared within classes that are <em>not</em>
 annotated with <code>@Configuration</code>. For example, bean methods may be declared
 in a <code>@Component</code> class or even in a <em>plain old class</em>. In such cases,
 a <code>@Bean</code> method will get processed in a so-called <em>'lite'</em> mode.

 <p>Bean methods in <em>lite</em> mode will be treated as plain <em>factory
 methods</em> by the container (similar to <code>factory-method</code> declarations
 in XML), with scoping and lifecycle callbacks properly applied. The containing
 class remains unmodified in this case, and there are no unusual constraints for
 the containing class or the factory methods.

 <p>In contrast to the semantics for bean methods in <code>@Configuration</code> classes,
 <em>'inter-bean references'</em> are not supported in <em>lite</em> mode. Instead,
 when one <code>@Bean</code>-method invokes another <code>@Bean</code>-method in <em>lite</em>
 mode, the invocation is a standard Java method invocation; Spring does not intercept
 the invocation via a CGLIB proxy. This is analogous to inter-<code>@Transactional</code>
 method calls where in proxy mode, Spring does not intercept the invocation &mdash;
 Spring does so only in AspectJ mode.

 <p>For example:

 <pre class="code">
 &#064;Component
 public class Calculator {
     public int sum(int a, int b) {
         return a+b;
     }

     &#064;Bean
     public MyBean myBean() {
         return new MyBean();
     }
 }</pre>

 <h3>Bootstrapping</h3>

 <p>See the @<a href="../../../../org/springframework/context/annotation/Configuration.html" title="org.springframework.context.annotation中的注释"><code>Configuration</code></a> javadoc for further details including how to bootstrap
 the container using <a href="../../../../org/springframework/context/annotation/AnnotationConfigApplicationContext.html" title="org.springframework.context.annotation中的类"><code>AnnotationConfigApplicationContext</code></a> and friends.

 <h3><code>BeanFactoryPostProcessor</code>-returning <code>@Bean</code> methods</h3>

 <p>Special consideration must be taken for <code>@Bean</code> methods that return Spring
 <a href="../../../../org/springframework/beans/factory/config/BeanFactoryPostProcessor.html" title="org.springframework.beans.factory.config中的接口"><code>BeanFactoryPostProcessor</code></a>
 (<code>BFPP</code>) types. Because <code>BFPP</code> objects must be instantiated very early in the
 container lifecycle, they can interfere with processing of annotations such as <code>@Autowired</code>,
 <code>@Value</code>, and <code>@PostConstruct</code> within <code>@Configuration</code> classes. To avoid these
 lifecycle issues, mark <code>BFPP</code>-returning <code>@Bean</code> methods as <code>static</code>. For example:

 <pre class="code">
     &#064;Bean
     public static PropertySourcesPlaceholderConfigurer pspc() {
         // instantiate, configure and return pspc ...
     }
 </pre>

 By marking this method as <code>static</code>, it can be invoked without causing instantiation of its
 declaring <code>@Configuration</code> class, thus avoiding the above-mentioned lifecycle conflicts.
 Note however that <code>static</code> <code>@Bean</code> methods will not be enhanced for scoping and AOP
 semantics as mentioned above. This works out in <code>BFPP</code> cases, as they are not typically
 referenced by other <code>@Bean</code> methods. As a reminder, a WARN-level log message will be
 issued for any non-static <code>@Bean</code> methods having a return type assignable to
 <code>BeanFactoryPostProcessor</code>.</div>
<dl>
<dt><span class="simpleTagLabel">从以下版本开始:</span></dt>
<dd>3.0</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../../org/springframework/context/annotation/Configuration.html" title="org.springframework.context.annotation中的注释"><code>Configuration</code></a>, 
<a href="../../../../org/springframework/context/annotation/Scope.html" title="org.springframework.context.annotation中的注释"><code>Scope</code></a>, 
<a href="../../../../org/springframework/context/annotation/DependsOn.html" title="org.springframework.context.annotation中的注释"><code>DependsOn</code></a>, 
<a href="../../../../org/springframework/context/annotation/Lazy.html" title="org.springframework.context.annotation中的注释"><code>Lazy</code></a>, 
<a href="../../../../org/springframework/context/annotation/Primary.html" title="org.springframework.context.annotation中的注释"><code>Primary</code></a>, 
<code>Component</code>, 
<a href="../../../../org/springframework/beans/factory/annotation/Autowired.html" title="org.springframework.beans.factory.annotation中的注释"><code>Autowired</code></a>, 
<a href="../../../../org/springframework/beans/factory/annotation/Value.html" title="org.springframework.beans.factory.annotation中的注释"><code>Value</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="annotation.type.optional.element.summary">
<!--   -->
</a>
<h3>可选元素概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="可选元素概要表, 列表可选元素和解释">
<caption><span>可选元素</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">可选元素和说明</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/springframework/beans/factory/annotation/Autowire.html" title="org.springframework.beans.factory.annotation中的枚举">Autowire</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/context/annotation/Bean.html#autowire--">autowire</a></span></code>
<div class="block">Are dependencies to be injected via convention-based autowiring by name or type?</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="java.lang中的类或接口">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/context/annotation/Bean.html#destroyMethod--">destroyMethod</a></span></code>
<div class="block">The optional name of a method to call on the bean instance upon closing the
 application context, for example a <code>close()</code> method on a JDBC
 <code>DataSource</code> implementation, or a Hibernate <code>SessionFactory</code> object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="java.lang中的类或接口">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/context/annotation/Bean.html#initMethod--">initMethod</a></span></code>
<div class="block">The optional name of a method to call on the bean instance during initialization.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="java.lang中的类或接口">String</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/context/annotation/Bean.html#name--">name</a></span></code>
<div class="block">The name of this bean, or if several names, a primary bean name plus aliases.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="java.lang中的类或接口">String</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/context/annotation/Bean.html#value--">value</a></span></code>
<div class="block">Alias for <a href="../../../../org/springframework/context/annotation/Bean.html#name--"><code>name()</code></a>.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="annotation.type.element.detail">
<!--   -->
</a>
<h3>元素详细资料</h3>
<a name="value--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>value</h4>
<pre><a href="../../../../org/springframework/core/annotation/AliasFor.html" title="org.springframework.core.annotation中的注释">@AliasFor</a>(<a href="../../../../org/springframework/core/annotation/AliasFor.html#value--">value</a>="name")
public abstract&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="java.lang中的类或接口">String</a>[]&nbsp;value</pre>
<div class="block">Alias for <a href="../../../../org/springframework/context/annotation/Bean.html#name--"><code>name()</code></a>.
 <p>Intended to be used when no other attributes are needed, for example:
 <code>@Bean("customBeanName")</code>.</div>
<dl>
<dt><span class="simpleTagLabel">从以下版本开始:</span></dt>
<dd>4.3.3</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../../org/springframework/context/annotation/Bean.html#name--"><code>name()</code></a></dd>
</dl>
<dl>
<dt>默认值:</dt>
<dd>{}</dd>
</dl>
</li>
</ul>
</li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="name--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>name</h4>
<pre><a href="../../../../org/springframework/core/annotation/AliasFor.html" title="org.springframework.core.annotation中的注释">@AliasFor</a>(<a href="../../../../org/springframework/core/annotation/AliasFor.html#value--">value</a>="value")
public abstract&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="java.lang中的类或接口">String</a>[]&nbsp;name</pre>
<div class="block">The name of this bean, or if several names, a primary bean name plus aliases.
 <p>If left unspecified, the name of the bean is the name of the annotated method.
 If specified, the method name is ignored.
 <p>The bean name and aliases may also be configured via the <a href="../../../../org/springframework/context/annotation/Bean.html#value--"><code>value()</code></a>
 attribute if no other attributes are declared.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../../org/springframework/context/annotation/Bean.html#value--"><code>value()</code></a></dd>
</dl>
<dl>
<dt>默认值:</dt>
<dd>{}</dd>
</dl>
</li>
</ul>
</li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="autowire--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>autowire</h4>
<pre>public abstract&nbsp;<a href="../../../../org/springframework/beans/factory/annotation/Autowire.html" title="org.springframework.beans.factory.annotation中的枚举">Autowire</a>&nbsp;autowire</pre>
<div class="block">Are dependencies to be injected via convention-based autowiring by name or type?
 <p>Note that this autowire mode is just about externally driven autowiring based
 on bean property setter methods by convention, analogous to XML bean definitions.
 <p>The default mode does allow for annotation-driven autowiring. "no" refers to
 externally driven autowiring only, not affecting any autowiring demands that the
 bean class itself expresses through annotations.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../../org/springframework/beans/factory/annotation/Autowire.html#BY_NAME"><code>Autowire.BY_NAME</code></a>, 
<a href="../../../../org/springframework/beans/factory/annotation/Autowire.html#BY_TYPE"><code>Autowire.BY_TYPE</code></a></dd>
</dl>
<dl>
<dt>默认值:</dt>
<dd>org.springframework.beans.factory.annotation.Autowire.NO</dd>
</dl>
</li>
</ul>
</li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="initMethod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initMethod</h4>
<pre>public abstract&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="java.lang中的类或接口">String</a>&nbsp;initMethod</pre>
<div class="block">The optional name of a method to call on the bean instance during initialization.
 Not commonly used, given that the method may be called programmatically directly
 within the body of a Bean-annotated method.
 <p>The default value is <code>""</code>, indicating no init method to be called.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../../org/springframework/beans/factory/InitializingBean.html" title="org.springframework.beans.factory中的接口"><code>InitializingBean</code></a>, 
<a href="../../../../org/springframework/context/ConfigurableApplicationContext.html#refresh--"><code>ConfigurableApplicationContext.refresh()</code></a></dd>
</dl>
<dl>
<dt>默认值:</dt>
<dd>""</dd>
</dl>
</li>
</ul>
</li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="destroyMethod--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>destroyMethod</h4>
<pre>public abstract&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="java.lang中的类或接口">String</a>&nbsp;destroyMethod</pre>
<div class="block">The optional name of a method to call on the bean instance upon closing the
 application context, for example a <code>close()</code> method on a JDBC
 <code>DataSource</code> implementation, or a Hibernate <code>SessionFactory</code> object.
 The method must have no arguments but may throw any exception.
 <p>As a convenience to the user, the container will attempt to infer a destroy
 method against an object returned from the <code>@Bean</code> method. For example, given
 an <code>@Bean</code> method returning an Apache Commons DBCP <code>BasicDataSource</code>,
 the container will notice the <code>close()</code> method available on that object and
 automatically register it as the <code>destroyMethod</code>. This 'destroy method
 inference' is currently limited to detecting only public, no-arg methods named
 'close' or 'shutdown'. The method may be declared at any level of the inheritance
 hierarchy and will be detected regardless of the return type of the <code>@Bean</code>
 method (i.e., detection occurs reflectively against the bean instance itself at
 creation time).
 <p>To disable destroy method inference for a particular <code>@Bean</code>, specify an
 empty string as the value, e.g. <code>@Bean(destroyMethod="")</code>. Note that the
 <a href="../../../../org/springframework/beans/factory/DisposableBean.html" title="org.springframework.beans.factory中的接口"><code>DisposableBean</code></a> callback interface will
 nevertheless get detected and the corresponding destroy method invoked: In other
 words, <code>destroyMethod=""</code> only affects custom close/shutdown methods and
 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html?is-external=true" title="java.io中的类或接口"><code>Closeable</code></a>/<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html?is-external=true" title="java.lang中的类或接口"><code>AutoCloseable</code></a> declared close methods.
 <p>Note: Only invoked on beans whose lifecycle is under the full control of the
 factory, which is always the case for singletons but not guaranteed for any
 other scope.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../../org/springframework/beans/factory/DisposableBean.html" title="org.springframework.beans.factory中的接口"><code>DisposableBean</code></a>, 
<a href="../../../../org/springframework/context/ConfigurableApplicationContext.html#close--"><code>ConfigurableApplicationContext.close()</code></a></dd>
</dl>
<dl>
<dt>默认值:</dt>
<dd>"(inferred)"</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</body>
</html>
